# -*- coding: utf-8 -*-
import click, yaml, sys
@click.command ()
@click.option ("--expert", "-e", type=click.BOOL, default=False, show_default=True, help="""Enable expert mode. This leaves out descriptions for settings 
def generate_config (expert):
	if expert:
		generate_cfg_expert()
	else:
		generate_cfg_normal()

def generate_cfg_normal ():
	click.echo ("Socketwrap configuration generation tool: generates YAML configuration files for the socketwrap program.")
	click.echo ("Welcome to the configuration generation tool! This tool generates YAML (YAMLAintMarkupLanguage) configuration files that socketwrap can use with the -C option. At any time during this generation process, you may press ctrl+c/ctrl+d or send the SIGTERM or SIGKILL signals to abort this process.")
	click.echo ("WARNING")
	click.echo ("Do not change the configuration file unless you know YAML. While the configuration file is quite simple to read, changing it may get undesirable results if you do not know the YAML markup language.")
	click.echo ("WARNING")
	click.echo ("To begin the configuration process, press enter.")
	input()
	config = dict()
	config["hostname"] = click.prompt ("""In computer networking, a hostname (archaically nodename) is a label that is assigned to a device connected to a computer network and that is used to identify the device in various forms of electronic communication, such as the World Wide Web. Hostnames may be simple names consisting of a single word or phrase, or they may be structured.\nOn the Internet, hostnames may have appended the name of a Domain Name System (DNS) domain, separated from the host-specific label by a period ('dot'). In the latter form, a hostname is also called a domain name. If the domain name is completely specified, including a top-level domain of the Internet, then the hostname is said to be a fully qualified domain name (FQDN). Hostnames that include DNS domains are often stored in the Domain Name System together with the IP addresses of the host they represent for the purpose of mapping the hostname to an address, or the reverse process.\nAn IP address (abbreviation of Internet Protocol address) is an identifier assigned to each computer and other device (e.g., printer, router, mobile device, etc.) connected to a TCP/IP network that is used to locate and identify the node in communications with other nodes on the network.\nVersion 4 of the Internet Protocol (IPv4) defines an IP address as a 32-bit number. However, because of the growth of the Internet and the depletion of available IPv4 addresses, a new version of IP (IPv6), using 128 bits for the IP address, was developed in 1995, and standardized as RFC 2460 in 1998. Its deployment commenced in the mid-2000s and is ongoing. IP addresses are usually written and displayed in human-readable notations, such as 172.16.254.1 in IPv4, and 2001:db8:0:1234:0:567:8:1 in IPv6.\nThe IP address space is managed globally by the Internet Assigned Numbers Authority (IANA), and by five regional Internet registries (RIR) responsible in their designated territories for assignment to end users and local Internet registries, such as Internet service providers. IPv4 addresses have been distributed by IANA to the RIRs in blocks of approximately 16.8Â million addresses each. Each ISP or private network administrator assigns an IP address to each device connected to its network. Such assignments may be on a static (fixed or permanent) or dynamic basis, depending on its software and practices.\nSpecify hostname or IP address""", default="127.0.0.1", type=click.STRING)
	config["port"] = click.prompt ("""In the internet protocol suite, a port is an endpoint of communication in an operating system. While the term is also used for female connectors on hardware devices (see https://en.wikipedia.org/wiki/Computer_port_(hardware) and https://en.wikipedia.org/wiki/Gender_of_connectors_and_fasteners), in software it is a logical construct that identifies a specific process or a type of network service.\nA port is always associated with an IP address of a host and the protocol type of the communication, and thus completes the destination or origination network address of a communication session. A port is identified for each address and protocol by a 16-bit number, commonly known as the port number. For example, an address may be 'protocol: TCP, IP address: 1.2.3.4, port number: 80', which may be written 1.2.3.4:80 when the protocol is known from context.\nSpecific port numbers are often used to identify specific services. Of the thousands of enumerated ports, 1024 well-known port numbers are reserved by convention to identify specific service types on a host. In the client-server model of application architecture, the ports that network clients connect to for service initiation provide a multiplexing service. After initial communication binds to the well-known port number, this port is freed by switching each instance of service requests to a dedicated, connection-specific port number, so that additional clients can be serviced. The protocols that primarily use ports are the transport layer protocols, such as the Transmission Control Protocol (TCP) and the User Datagram Protocol (UDP).\nPorts were unnecessary on direct point-to-point links when the computers at each end could only run one program at a time. Ports became necessary after computers became capable of executing more than one program at a time and were connected to modern networks.\nSpecify port""", default=3000, type=click.INT)
	config["append_newline"] = click.confirm ("""Automatically append a newline to each buffer of data received from the subprocess's streams if it doesn't already have one?\nThis isn't normally useful, but for some programs such as shells which write the prompt and don't follow it with a newline character (which shows the command you type on the same line), you won't see that prompt when using them with socketwrap.\nThis option flag fixes such problems, though if the amount of output is extremely large in a rare case newlines could be mistakenly added where they aren't supposed to go by this option.""", default=False, show_default=True, prompt_suffix="")
	config["enable_multiple_connections"] = click.confirm ("""Allow multiple connections? Each one will be able to send to the subprocess as well as receive.""", default=False, show_default=True, prompt_suffix="")
	config["loop_delay"] = click.prompt ("""The loop delay is how long to sleep for at the end of each main loop iteration. This is meant to reduce CPU spiking of the main (socket-handling) thread. Setting this value too high introduces unnecessary lag when handling new data from clients or the wrapped command; setting it too low defeats the purpose. If it's set to 0, the delay is disabled (not recommended!).\nSpecify loop delay""", default=0.025, type=click.FLOAT, show_default=True)
	config["thread_sleep_time"] = config.prompt ("""The thread sleep time is how long the thread that reads output from the given command will sleep. Setting this to a lower value will make socketwrap notice and send output quicker, but will raise it's CPU usage.\nSpecify thread sleep time""", default=0.1, type=click.FLOAT, show_default=True)
	config["enable_ssl"] = click.confirm ("""Transport Layer Security (TLS) and its predecessor, Secure Sockets Layer (SSL), both frequently referred to as "SSL", are cryptographic protocols that provide communications security over a computer network.\nSeveral versions of the protocols find widespread use in applications such as web browsing, email, Internet faxing, instant messaging, and voice-over-IP (VoIP). Websites are able to use TLS to secure all communications between their servers and web browsers.\nThe Transport Layer Security protocol aims primarily to provide privacy and data integrity between two communicating computer applications. When secured by TLS, connections between a client (e.g., a web browser) and a server (e.g., wikipedia.org) have one or more of the following properties:\n* The connection is private (or secure) because symmetric cryptography is used to encrypt the data transmitted. The keys for this symmetric encryption are generated uniquely for each connection and are based on a shared secret negotiated at the start of the session (see https://en.wikipedia.org/wiki/Transport_Layer_Security#TLS_handshake). The server and client negotiate the details of which encryption algorithm and cryptographic keys to use before the first byte of data is transmitted (see https://en.wikipedia.org/wiki/Transport_Layer_Security#Algorithm). The negotiation of a shared secret is both secure (the negotiated secret is unavailable to eavesdroppers and cannot be obtained, even by an attacker who places themselves in the middle of the connection) and reliable (no attacker can modify the communications during the negotiation without being detected).\n* The identity of the communicating parties can be authenticated using public-key cryptography. This authentication can be made optional, but is generally required for at least one of the parties (typically the server).\n* The connection ensures integrity because each message transmitted includes a message integrity check using a message authentication code to prevent undetected loss or alteration of the data during transmission.\nIn addition to the properties above, careful configuration of TLS can provide additional privacy-related properties such as forward secrecy, ensuring that any future disclosure of encryption keys cannot be used to decrypt any TLS communications recorded in the past.\nTLS supports many different methods for exchanging keys, encrypting data, and authenticating message integrity (see https://en.wikipedia.org/wiki/Transport_Layer_Security#Algorithm). As a result, secure configuration of TLS involves many configurable parameters, and not all choices provide all of the privacy-related properties described in the list above (see https://en.wikipedia.org/wiki/Transport_Layer_Security#keyexchange-table, https://en.wikipedia.org/wiki/Transport_Layer_Security#cipher-table, and https://en.wikipedia.org/wiki/Transport_Layer_Security#integrity-table).\nAttempts have been made to subvert aspects of the communications security that TLS seeks to provide and the protocol has been revised several times to address these security threats (see https://en.wikipedia.org/wiki/Transport_Layer_Security#Security). Developers of web browsers have also revised their products to defend against potential security weaknesses after these were discovered (see https://en.wikipedia.org/wiki/Transport_Layer_Security#Web_browsers).\nThe TLS protocol comprises two layers: the TLS record protocol and the TLS handshake protocol.\nTLS is a proposed Internet Engineering Task Force (IETF) standard, first defined in 1999 and updated in RFC 5246 (August 2008) and RFC 6176 (March 2011). It builds on the earlier SSL specifications (1994, 1995, 1996) developed by Netscape Communications for adding the HTTPS protocol to their Navigator web browser.\nSource: https://en.wikipedia.org/wiki/Transport_Layer_Security\nEnable SSL support""", default=False, show_default=True)
	if "enable_ssl" in config:
		config["certfile"] = config.prompt ("""In cryptography, a public key certificate, also known as a digital certificate or identity certificate, is an electronic document used to prove the ownership of a public key. The certificate includes information about the key, information about the identity of its owner (called the subject), and the digital signature of an entity that has verified the certificate's contents (called the issuer). If the signature is valid, and the software examining the certificate trusts the issuer, then it can use that key to communicate securely with the certificate's subject. In email encryption, code signing, and e-signature systems, a certificate's subject is typically a person or organization. However, in Transport Layer Security (TLS) a certificate's subject is typically a computer or other device, though TLS certificates may identify organizations or individuals in addition to their core role in identifying devices. TLS, sometimes called by its older name Secure Sockets Layer (SSL), is notable for being a part of HTTPS, a protocol for securely browsing the web.\nIn a typical public-key infrastructure (PKI) scheme, the certificate issuer is a certificate authority (CA), usually a company that charges customers to issue certificates for them. By contrast, in a web of trust scheme, individuals sign each other's keys directly, in a format that performs a similar function to a public key certificate.\nThe most common format for public key certificates is defined by X.509. Because X.509 is very general, the format is further constrained by profiles defined for certain use cases, such as Public Key Infrastructure (X.509) as defined in RFC 5280.\nSource: https://en.wikipedia.org/wiki/Public_key_certificate\nNote: A self-signed certificate can be generated by using the following command:\nopenssl req -x509 -newkey rsa:<bits> -keyout <filename> -out <filename> -days <expdays>\nOr, to use one without a password (not recommended unless testing!):\nopenssl req -x509 -newkey rsa:<bits> -keyout <filename> -out <filename> -days <expdays> -nodes\nWhere:\n<bits> are the numbers of bits (such as 1024, 2048, 4096, 8192, etc.) Recommended values are 2048 and 4096.\n<filename> and <filename>: The first one (with the -keyout parameter) is the filename for the keyfile, which will be asked after the certfile. The second is the certfile, which will be asked first.\n<expdays> are the amount of days before the certificate expires. 365 is usually a good choice\nSpecify public key certificate file""", default=None, type=click.STRING, show_default=True, confirmation_prompt=True)
		config["keyfile"] = click.prompt ("Specify public key certificate key file", default=None, show_default=True, type=click.STRING, confirmation_prompt=True)
	click.echo ("Please review your below configuration to ensure it is correct. Answering y/yes will export the configuration to a .yaml file for loading later; answering n/no will reconfigure from the beginning.")
	for key, value in config.items():
		click.echo ("{}: {}".format (key, value))
	correct = click.prompt ("Is this configuration correct?", default=True, show_default=True, prompt_suffix="", type=click.BOOL)
	if correct == True:
		file = click.prompt ("Specify configuration file filename ended with .yaml", default="config.yaml", show_default=True, type=click.STRING)
		with open (file, "w") as f:
			yaml.dump (config, f)
		else:
			generate_cfg_normal()
	click.echo ("Configuration written to {}.".format (file))
	sys.exit (0)

def generate_cfg_expert ():
	config = {}
	config["hostname"] = click.prompt ("""Specify hostname or IP address""", default="127.0.0.1", type=click.STRING)
	config["port"] = click.prompt ("""Specify port""", default=3000, type=click.INT)
	config["append_newline"] = click.confirm ("""Automatically append a newline to each buffer of data received from the subprocess's streams if it doesn't already have one?""", default=False, show_default=True, prompt_suffix="")
	config["enable_multiple_connections"] = click.confirm ("""Allow multiple connections?""", default=False, show_default=True, prompt_suffix="")
	config["loop_delay"] = click.prompt ("""Specify loop delay""", default=0.025, type=click.FLOAT, show_default=True)
	config["thread_sleep_time"] = config.prompt ("""Specify thread sleep time""", default=0.1, type=click.FLOAT, show_default=True)
	config["enable_ssl"] = click.confirm ("""Enable SSL support""", default=False, show_default=True)
	if "enable_ssl" in config:
		config["certfile"] = click.prompt ("""Specify public key certificate file""", default=None, type=click.STRING, show_default=True, confirmation_prompt=True)
		config["keyfile"] = click.prompt ("Specify public key certificate key file", default=None, show_default=True, type=click.STRING, confirmation_prompt=True)
	click.echo ("Please review your below configuration to ensure it is correct. Answering y/yes will export the configuration to a .yaml file for loading later; answering n/no will reconfigure from the beginning.")
	for key, value in config.items():
		click.echo ("{}: {}".format (key, value))
	correct = click.prompt ("Is this configuration correct?", default=True, show_default=True, prompt_suffix="", type=click.BOOL)
	if correct == True:
		file = click.prompt ("Specify configuration file filename ended with .yaml", default="config.yaml", show_default=True, type=click.STRING)
		with open (file, "w") as f:
			yaml.dump (config, f)
		else:
			generate_cfg_expert()
	click.echo ("Configuration written to {}.".format (file))
	sys.exit (0)

if __name__ == "__main__":
	try:
		context = generate_config.make_context(sys.argv[0], sys.argv[1:])
		with context:
			return_code = generate_config.invoke(context)
	except click.ClickException as e:
		return_code = getattr("e", "return_code", None) or 1
		e.show()
	sys.exit(return_code)
